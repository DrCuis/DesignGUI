@node What is a Morph after all?
@chapter What is a Morph after all?

@*

The Cuis' Morph framework is fundamental to @cuis{}, every single visual piece the user sees and interacts with in the Cuis' window is a morph. A morph offers both visual representation and interactivity with keyboard and mouse inputs.

@menu
* A World of Morphs::
* Morph Hierarchy::
@end menu


@node A World of Morphs
@section A World of Morphs

@cindex morph @subentry count
A bit of introspection reveals how many @class{Morph} instances are in use in the @cuis{} living system:

@smalltalkExampleCaption{How many buttons?,ch04-buttonCount,
PluggableButtonMorph allInstances size
@result{} 288@footnote{As a recall, you @emph{execute-and-print} to get the result printed; otherwise, it is only executed. Use shortcut @kbd{Ctrl-p} instead of @kbd{Ctrl-d}.}}

The previous example asked for one specific type of morph. What about asking for all types of morph?

@smalltalkExampleCaption{How many morphs are operating on the system?,ch-04-allMorphCount,
Morph allSubclasses inject: 0 into: [:count :aClass |
   count + aClass allInstances size]
@result{} 1558}

This number, likely different on your own @cuis{} system, represents all the objects necessary to operate visually the system. This count changes all the time, new morph are created and ones no more necessary are garbage collected regularly. Play a bit with the system and evaluate again this count.

@subsection Tree of morphs
@cindex morph @subentry sub-morph
@cindex morph @subentry owner
Any morph can contain other morphs. We already know a @class{LayoutMorph} contains several morphs and manage the way there are layed out; these is reflected in the @smalltalk{submorphs} attribute of each morph, when this collection is empty it means there is no sub-morph. In the other hand, a morph knows about its unique owner: the @smalltalk{owner} attribute of each morph refers to the morph owning it. And as you can expect it, the owner morph @smalltalk{submorphs} attribute contains the owned attribute as well.

Then what happens when the @smalltalk{owner} attribute is @smalltalk{nil}? The morph is simply not visible! This double link between owner and owned is very convenient and necessary for the morph framework depending on the situation. For example, while an owned morph may have its own local coordinates system for its drawing operations, it can refer to its owner to know about its global coordinates situation, from the point of view of the owner or even from the World perspective -- @emph{simplified for readiness}:

@smalltalkExample{Morph>>externalizeToWorld: aPoint
"aPoint is in own coordinates. Answer is in world coordinates."
| inOwners |
inOwners := self externalize: aPoint.
@return{} owner externalizeToWorld: inOwners}

Access to the owner is also useful for mundane aspect as the style. A morph asks its owner's color to draw itself accordingly:

@smalltalkExample{MenuLineMorph>>drawOn: aCanvas 
| baseColor |
baseColor := owner color.
aCanvas
   fillRectangle: (`0@@0` corner: extent x @@ (extent y / 2))
   color: baseColor twiceDarker.
...}		

In the other hand, the owner, depending on its nature, can decide how to dispose its sub-morphs, like does a @class{LayoutMorph} by first requesting which sub-morphs to lay out:

@smalltalkExample{LayoutMorph>>submorphsToLayout
"Select those that will be layout"
@return{} submorphs select: [ :m | m visible ]}


@subsection Halo of icons
@cindex morph @subentry halo
Because everything is an object in @cuis{}, every visual part of the system is represented through an object the user can interact and inspect from a system level perspective. The Halo system, designed with objects, is a special visual tool to know more about specific @class{Morph} instances. It is invoked on any @class{Morph} instance by a middle button click, a halo of coloured icons then shows up, surrounding the selected morph.

@figure{Halo of a @class{LayoutMorph},ch04-halo,5}

Supplementary click accesses a sub-morph under the mouse pointer, the halo is then updated accordingly. When pressing the @kbd{Shift} key, the direction of morph selection is changed: the owner of the morph the mouse is over is selected instead.

Each icon allows specific actions. We previously discussed the sub-morph and owner relationship among morphs. In a halo, the orange wrench icon at the right gives access to a set of actions to explore these relations, try it!

@figure{Actions to explore sub-morph and owner relations,ch04-haloDebug,4}

@subsection The special World morph
@cindex morph @subentry world
In @cuis{}, there is a special morph, a @class{WorldMorph} instance, representing the top morph of @cuis{}.

@smalltalkExampleCaption{There is only one World!,ch04-worldCount,
WorldMorph allInstances
@result{} @{ [world]@}}

@cindex morph @subentry explore
Guess what? It is the only morph without an owner and still visible. Take any morph in the world, invoke its halo, then from the wrench icon, select the menu entry @label{explore morph} and browser the chain of owner until you reach the World, you discover it does not have owner:

@figure{The chain of owners of a morph,ch04-morphOwners,5}

Execute the following code to experiment from an inspector opened in Morph.

@smalltalkExampleCaption{Create@comma{} inspect and open in the World a morph,newInspectMorph,
Morph new ::
   inspect;
   openInWorld}

@cindex morph @subentry flash
A blue rectangular morph shows up at the top left corner of the @cuis{} window. Sometime, the morph we are playing with is out of sight, or we are not sure where it is; a convenient way to find is to ask it flashes itself. In the inspector, execute the code @smalltalk{self flash}.

Any morph knows about its World, in the inspector execute: @smalltalk{self runningWorld}. As a World is a Morph class, we can flash it too: @smalltalk{self runningWorld flash}.

@node Morph Hierarchy
@section Morph Hierarchy
In a stock @cuis{} system, browse the @class{Morph} class; it is in the @label{Morphic>Kernel} class category, here are the most fundamental type of @class{Morph}:

@cindex morph @subentry kernel
@indentedblock
Morph
   @indentedblock
   PlacedMorph
      @indentedblock
      BoxMorph      
       @indentedblock
       ColoredBoxMorph
         @indentedblock
         BorderedBoxMorph
         
         PasteUpMorph

            @indentedblock
            WorldMorph
            @end indentedblock            
         @end indentedblock
       @end indentedblock
      HandMorph
      @end indentedblock      
   @end indentedblock
@end indentedblock

Observe how the @class{Morph} has only @class{PlacedMorph} as its subclass, this is odd and it requires some scrunity by looking at the differences between these two classes. Indeed, if @class{Morph} has only one sub-class, the two should be merged. Let's examine the attributes of the @class{Morph} class:

@smalltalkExampleCaption{Definition of the @class{Morph} class,morphDefinition,
Object subclass: #Morph
   instanceVariableNames: 'owner submorphs properties id privateDisplayBounds'
   classVariableNames: 'LastMorphId'
   poolDictionaries: ''
   category: 'Morphic-Kernel'}

@cindex morph @subentry properties
There are the expected @smalltalk{owner} and @smalltalk{submorphs} attributes; @smalltalk{properties} is set, when needed, as a dictionary to dynamically add attributes or behaviors -- with appropriate bloc of code -- to any @class{Morph} instances. There are companion methods to set or retrieve a property.

@figure{@class{Morph}'s methods to manipulate properties,ch04-property,8}

This @smalltalk{properties} attribute is used a lot. Observe how it is used to set a specific name to a @class{Morph} instance:

@smalltalkExampleCaption{Methods to set and get a morph name, morphNameMethods,
Morph>>name: anObject
  "Set the morphName property"
   self setProperty: #morphName toValue: anObject

Morph>>name
   "Answer the value of morphName"
   @return{} self valueOfProperty: #morphName}

An example to illustrate its use case: create a new morph as see in @ref{newInspectMorph}, then in the inspector execute @smalltalk{self name: 'Glouby'}, then observe how @smalltalk{properties} was amended with the dictionary entry @smalltalk{#morphName->'Glouby'}; when invoking the morph's halo, its new name is printed too.

@subsection The basic type of Morph

@subsection Morph you can move


A Morph (from the Greek "shape" or "form") is an interactive graphical object. General information on the Morphic system can be found at http://wiki.squeak.org/squeak/morph. 

Morphs exist in a tree, rooted at a World (a WorldMorph). The morphs owned by a morph are its submorphs. Morphs are drawn recursively; if a Morph has no owner it never gets 
drawn. To hide a Morph and its submorphs, send the #visible: message. 

Subclass PlacedMorph defines a local coordinate system (see its class comment). Morphs NOT in the PlacedMorph hierarchy live in the space defined by their owner. Their local coordinate system is the same as the owner's. They ignore #morphPosition:.

Local coordinates are used in the #drawOn: method (the Canvas understands positions in the local coordinate system), for the positions of submorphs (for example #morphPosition and #morphPosition:) and for positions carried by mouse events.

Events are delivered to morphs in Z-order, i.e. if a morph occludes another the event is only delivered to the foremost (just like physical objects). Events received by a morph carry positions in the local coordinate system.

Structure:
instance var 				Type 						Description 
owner 				Morph or nil		 				My parent Morph, or nil for the top-level Morph, which is a WorldMorph
submorphs 				Array 						My child Morphs.




