@node Handle user interaction
@chapter Handle user interaction

@*

This chapter does not cover low-level event handling like
mouse clicks, mouse hovers, and key presses.
Instead, it covers how to use existing widgets, pluggable morphs, etc.,
and how to set up a model.
Important facets to cover include the update/changes and observer pattern.

@node Buttons
@section Buttons

Perhaps the simplest user interaction to implement
is responding to button clicks.
The @class{PluggableButtonMorph} supports this.

Several of the @class{Morph} subclasses are "pluggable". This means
they can be configured through composition rather than inheritance.
Configuration is achieved by specifying a model object and a selector
for messages to be sent to the model object when an interaction occurs.

Instances of the @class{PluggableButtonMorph} class can be
created with the @msg{model:action:label:} class method.
The @smalltalk{model:} keyword specifies a model object,
the @smalltalk{action:} keyword specifies a selector for the model object, and
the @smalltalk{label:} keyword specifies the text that appears in the button.

Let's demonstrate using a @class{PluggableButtonMorph} by
defining a class that opens a window containing a single button.
Initially the window background color is white.
Clicking the button toggles the color between red and blue.

Create the following class.

@smalltalkExample{Object subclass: #ButtonDemo
    instanceVariableNames: 'layout'
    classVariableNames: ''
    poolDictionaries: ''
    category: 'Demo'}

Define the following instance methods.

@smalltalkExample{initialize
    | button extent window |
    
    button := PluggableButtonMorph
        model: self
        action: #toggleColor
        label: 'Toggle'.
    button setBalloonText: 'toggle background color'.
    window := SystemWindow new.
    window
        setLabel: 'Button Demo';
        addMorph: button;
        openInWorld.
        
    extent := button morphExtent.
    "Add some space to the left and right of the button label."
    button morphExtent: (extent x + 15) @ extent y.
        
    "Set window size to the smallest height that contains its submorphs.
    This must be done AFTER the window is opened."
    layout := window layoutMorph.
    layout padding: 10.
    window morphExtent: 300 @@ layout minimumExtent y.} 

@smalltalkExample{toggleColor
    
    layout color: (
        layout color = Color red
            ifTrue: [ Color blue ]
            ifFalse: [ Color red ]
    )}

Open a Workspace and evaluate @smalltalk{ButtonDemo new}.
Hover over the "Toggle" button for a second
to see its tooltip (a.k.a balloon text).
Click the "Toggle" button several times and
note how the window background color changes.

@node Popups
@section Popups

The class @class{PopUpMenu} provides an easy way to render a dialog that
displays information, asks the user for confirmation,
or ask the user to select an option.
It is similar to the JavaScript DOM functions @code{alert} and @code{confirm}.
For example:

@figure{PopupMenu inform, ch04-popupmenu-inform, 8}

@smalltalkExample{PopUpMenu inform: 'Something interesting just happened.'.}

@figure{PopupMenu confirm, ch04-popupmenu-confirm, 5}

@smalltalkExample{likesIceCream := PopUpMenu confirm: 'Do you like ice cream?'.
likesIceCream print. "prints true or false"}

@figure{PopupMenu confirm:trueChoice:falseChoice:, ch04-popupmenu-confirm-truechoice-falsechoice, 5}

@smalltalkExample{likesIceCream := PopUpMenu
    confirm: 'Do you like ice cream?'
    trueChoice: 'Love it!'
    falseChoice: 'Not for me'.
likesIceCream print. "prints true or false"}

@figure{PopupMenu withCaption:chooseFrom, ch04-popupmenu-withcaption-choosefrom, 4}

@smalltalkExample{color := PopUpMenu withCaption: 'Choose a color.' chooseFrom: #('red' 'green' 'blue').
color print. "prints choice index 1, 2, or 3"}

The @class{SelectionMenu} class is a subclass of @class{PopupMenu}.
For example:

@figure{SelectionMenu, ch04-selectionmenu, 3}

@smalltalkExample{
labels := #(burrito enchilada taco chips quacamole salsa water soda tea).
lines := #(3 6). "draw lines after these indexes"
menu := SelectionMenu labels: labels lines: lines.
selection := menu startUpMenu.
selection print. "prints selected label index"}

The following code demonstrates opening a @class{SelectionMenu}
when a button is clicked.

@figure{SelectionMenu closed, ch04-selectionmenu1, 6}

@figure{SelectionMenu open, ch04-selectionmenu2, 6}

@figure{SelectionMenu selected, ch04-selectionmenu3, 6}

Define the following class:

@smalltalkExample{Object subclass: #MenuDemo
    instanceVariableNames: 'colorButton colorMenu statusLabel colors window'
    classVariableNames: ''
    poolDictionaries: ''
    category: 'Demos'}

Define the following instance methods:

@smalltalkExample{initialize
    | layout |

    colorButton := PluggableButtonMorph
        model: self
        action: #openMenu
        label: 'Select Color'.

    colors := #(red orange yellow green blue purple).
    colorMenu := SelectionMenu labels: colors lines: #().

    statusLabel := LabelMorph contents: ''.

    window := SystemWindow new.
    window
        setLabel: 'Menu Demo';
        addMorph: colorButton;
        addMorph: statusLabel;
        openInWorld.

    "Set window size to the smallest height that contains its submorphs.
    This must be done AFTER the window is opened."
    layout := window layoutMorph.
    layout separation: 10.
    window morphExtent: 300 @ layout minimumExtent y.

openMenu
    | color colorName index |

    index := colorMenu startUpMenu.
    index = 0 ifFalse: [
        colorName := colors at: index.
        colorButton label: colorName.
        statusLabel contents: ('You selected @{1@}.' format: @{ colorName @}).

        color := colorName
            ifNil: [ Color gray ]
            ifNotNil: [ [ Color perform: colorName ] on: MessageNotUnderstood do: [ Color gray ] ].
        window layoutMorph color: (color alpha: 0.6).
    ]}

To run this, evaluate @smalltalk{MenuDemo new} in a Workspace.
@node Text Entry
@section Text Entry

The @class{TextModelMorph} class
can be used for single or multiple line text entry.

The following code creates an instance of @class{TextModelMorph},
changes its value, and prints its value:

@smalltalkExample{tmm := TextModelMorph withText: 'initial content'.
tmm openInWorld.
tmm editor actualContents: 'new content'.
tmm text print.}

Typically you will want to modify many aspects of this morph
such as its size and whether words automatically wrap to a new lines.

The value associated with a @class{TextModelMorph} is either
held in a @class{TextModel} object or a @class{Text} object.

There are three common ways to create an instance of @class{TextModelMorph}.
The choice is based on how the initial value is supplied
and where the current value is held.

@enumerate

@item
@smalltalk{TextModelMorph withText: aTextOrString}

   This creates a @class{TextModel} object
   that is initialized with the given value,
   passes it to the next method, and returns what that returns.

@item
@smalltalk{TextModelMorph withModel: aTextModel}

   The approach allows the same @class{TextModel} to be used by multiple other morphs.
   It creates an instance, sets its model to @smalltalk{aTextModel},
   and returns the instance.

@item
@smalltalk{TextModelMorph textProvider: aTextProvider textGetter: selectorSymbol1 textSetter: selectorSymbol2}

   This approach allows the value to maintained in
   any object (@smalltalk{aTextProvider}) that responds to the given selectors.
   It creates an instance, sets @smalltalk{newModel} to
   an instance of @class{PluggableTextModel} that uses @smalltalk{aTextProvider},
   adds @smalltalk{aTextProvider} as a dependent of @smalltalk{newModel},
   sets its model to @smalltalk{newModel},
   and returns the instance.

@end enumerate

The default background color of a @class{TextModelMorph} is white.
A @class{TextModelMorph} only displays a border when it has focus.
One way to make its bounds apparent when it doesn't have focus
is to set the background color of the parent component.

@smalltalkExample{tmm owner color: (Color blue alpha: 0.1)}

Another way is to set the background color of the @class{TextModelMorph}.

@smalltalkExample{tmm color: (Color blue alpha: 0.1)}

By default, words that would extend past the right side wrap to the next line.
To prevent wrapping:

@smalltalkExample{tmm wrapFlag: false}

By default, when there are more lines than fit in the height,
a vertical scroll bar appears.
When wrapping is turned off, if the text does not fit in the width
then a horizontal scroll bar appears.

To prevent scroll bars from appearing,
send one of the following messages to an instance:

@itemize
@item
@msg{hHideScrollBar} for horizontal (doesn't seem to work!)

@item
@msg{vHideScrollBar} for vertical (doesn't seem to work!)

@item
@msg{hideScrollBarsIndefinitely} for both
@end itemize

The default size of a @class{TextModelMorph} is 200 by 100.
This is set in the @method{initialize} method of @class{PluggableMorph},
which is the superclass of @class{PluggableScrollPane},
which is the superclass of @class{TextModelMorph}.
Depending on the font, the default size displays around four lines
of wrapping text with around 17 characters per line.

To change the size:

@smalltalkExample{tmm morphExtent: width @@ height}

The size should include space for scroll bars if they may be needed.

Setting the height to zero causes it to actually be set to
the height required for a single line in the current font.

By default, pressing the tab key does not move focus from
one @class{TextModelMorph} instance to another.
To enable this, do the following for each instance:

@smalltalkExample{tmm tabToFocus: true}

When the user changes the text in a @class{TextModelMorph},
the object that holds its value is not automatically updated.
To manually request the update:

@smalltalkExample{tmm scroller acceptContents}

There are multiple ways to configure user actions to trigger an update.
The easiest are:

@smalltalkExample{tmm acceptOnAny: true. "updates after every keystroke"
tmm acceptOnCR: true. "updates after return key is pressed"}

To listen for changes to the value of a @class{TextModelMorph}:

@smalltalkExample{tmm keystrokeAction: [:event |
    | value |
    value := tmm text.
    "Do something with the value."
].}

By default, if the user attempts to close a @class{SystemWindow}
and it contains @class{TextModelMorph} instances that have unsaved changes,
they are asked to confirm this with the message
"Changes have not been saved. Is it OK to cancel those changes?".
The user must select "Yes" to close the window.
To disable this check for a particular instance of @class{TextModelMorph},
send it @msg{askBeforeDiscardingEdits:} with the argument @smalltalk{false}.

The following code creates a single-line text input
with a given width that never shows scroll bars:

@smalltalkExample{tmm := TextModelMorph withText: '' ::
    hideScrollBarsIndefinitely;
    morphExtent: 200 @@ 0; "calculates required height for one line"
    wrapFlag: false.}

If the text exceeds the width,
use the left and right arrow keys to scroll the text.

To select all the content in an instance, send it @msg{selectAll}.

To select content from one index to another where both are inclusive:

@smalltalkExample{tmm selectFrom: startIndex to: endIndex.}

To place the text cursor at the end of the current content:

@smalltalkExample{index := tmm text size + 1.
tmm selectFrom: index to: index.}

The following code demonstrates listening for key events.
It prints their ASCII codes and character representations to the Transcript.

@smalltalkExample{tmm keystrokeAction: [ :evt |
   evt keyValue print.
   evt keyCharacter print.
].}

Let's combine what we have learned above to create a small application.
The user can enter their first and last name.
Clicking the "Greet" button displays a greeting message below the button.

@figure{User Interaction Demo, ch04-userinteraction-example1, 7} 

Create the class @class{UserInteractionDemo} as follows:

@smalltalkExample{Object subclass: #UserInteractionDemo
    instanceVariableNames: 'firstName greetLabel lastName'
    classVariableNames: ''
    poolDictionaries: ''
    category: 'Demo'}

Define the following accessor methods:

@smalltalkExample{firstName
    ^ firstName

firstName: aString
    firstName := aString

lastName
    ^ lastName

lastName: aString
    lastName := aString}

Define the instance method @method{} as follows:

@smalltalkExample{textEntryOn: aSymbol
    "Answer a TextModelMorph where aSymbol provides the name for the getter and setter."
    | entry |
        
    entry := TextModelMorph
        textProvider: self
        textGetter: aSymbol
        textSetter: (aSymbol, ':') asSymbol ::
        acceptOnAny: true;
        askBeforeDiscardingEdits: false;
        hideScrollBarsIndefinitely;
        "Width is made proportional below.
        Setting height to zero causes it to use minimum height for one line."
        morphExtent: 0 @@ 0;
        tabToFocus: true;
        wrapFlag: false.
    entry layoutSpec proportionalWidth: 1.
    ^ entry.}

Define the instance method @method{rowLabel:} as follows:

@smalltalkExample{rowLabeled: aString for: aMorph
    "Answer a row LayoutMorph containing a LabelMorph and a given morph."
    | row |
        
    row := LayoutMorph newRow
        gap: 10;
        addMorph: (LabelMorph contents: aString);
        addMorph: aMorph.
    row layoutSpec proportionalHeight: 0.
    ^ row.}

Define the instance method @method{greet} as follows:

@smalltalkExample{greet
    | greeting |

    greeting := firstName isEmpty
        ifTrue: ''
        ifFalse: [ 'Hello @{1@} @{2@}!' format: @{firstName. lastName@} ].
    greetLabel contents: greeting.}

Define the instance method @method{initialize} as follows:

@smalltalkExample{initialize
    | button extent firstNameEntry form image lastNameEntry window |
    
    firstName := ''.
    lastName := ''.
    
    "Relative file paths start from the Cuis-Smalltalk-Dev-UserFiles directory."
    form := Form fromFileNamed: './hot-air-balloon.png' :: magnifyBy: 0.5.
    image := ImageMorph newWith: form.
    
    firstNameEntry := self textEntryOn: #firstName.
    lastNameEntry := self textEntryOn: #lastName.
    button := PluggableButtonMorph model: self action: #greet label: 'Greet'.
    
    greetLabel := LabelMorph contents: ''.
    
    window := SystemWindow new.
    window layoutMorph separation: 10.
    window
        setLabel: 'User Interaction Demo';
        addMorph: image;
        addMorph: (self rowLabeled: 'First Name:' for: firstNameEntry);
        addMorph: (self rowLabeled: 'Last Name:' for: lastNameEntry);
        addMorph: button;
        addMorph: greetLabel;
        openInWorld.
        
    "Set a background color so it's clear where the TextModelMorphs
    are placed when they do not have focus."
    window layoutMorph color: (Color blue alpha: 0.1).
            
    "Set window size to the smallest height that contains its submorphs.
    This must be done AFTER the window is opened."
    extent := window layoutMorph minimumExtent.
    window morphExtent: 400 @@ extent y.}

@node Lists
@section Lists

The @class{PluggableListMorph} displays a scrollable list of items.
Users can select an item by clicking it or by typing its first few letters.

Let's create a small application that allows users to select a color
from a list to change the background color of the window.
Users can also add new colors and delete existing colors.

In addition to demonstrating the use of @class{PluggableListMorph},
we will also see how to disable buttons when their use is not appropriate.

@figure{List Demo, ch04-userinteraction-example2, 5} 

Create the following class:

@smalltalkExample{Object subclass: #ListDemo
    instanceVariableNames: 'colorList colors deleteButton
        newColorEntry selectedColorIndex selectedLabel window'
    classVariableNames: ''
    poolDictionaries: ''
    category: 'Demos'}

Add the following instance methods:

@smalltalkExample{initialize
    | addButton layout row |
    
    colors := SortedCollection newFrom: #(red orange yellow green blue purple).
    selectedColorIndex := 0.
    colorList := PluggableListMorph
        withModel: self
        listGetter: #colors
        indexGetter: #selectedColorIndex
        indexSetter: #selectedColorIndex:.
    colorList layoutSpec proportionalWidth: 1.
    
    newColorEntry :=  self textEntryOn: #newColor.
    newColorEntry emptyTextDisplayMessage: 'new color'.
    
    addButton := PluggableButtonMorph model: self action: #addColor label: 'Add'.
    
    row := LayoutMorph newRow
        gap: 10;
        addMorph: newColorEntry;
        addMorph: addButton.

    deleteButton := PluggableButtonMorph
        model: self
        action: #deleteColor
        label: 'Delete Selected Color'.
    
    selectedLabel := LabelMorph contents: ''.
    
    window := SystemWindow new.
    window
        setLabel: 'List Demo';
        addMorph: colorList;
        addMorph: row;
        addMorph: deleteButton;
        addMorph: selectedLabel;
        openInWorld.
    
    self selectedColorIndex: 0. "sets initial background color"

    "Set window size to the smallest height that contains its submorphs.
    This must be done AFTER the window is opened."
    layout := window layoutMorph.
    layout separation: 10.
    window morphExtent: 250 @@ layout minimumExtent y.}

@smalltalkExample{addColor
    self newColor: newColorEntry text}

@smalltalkExample{colors
    ^ colors}

@smalltalkExample{deleteColor

    selectedColorIndex = 0 ifFalse: [
        colors removeAt: selectedColorIndex.
        self selectedColorIndex: 0.
        colorList updateList.
        selectedLabel contents: ''.
    ]}

@smalltalkExample{newColor
    "In this app there is no need to retrieve this value
    or even hold it in an instance variable, but
    TextModelMorph requires that this method exists."
    
    ^ ''}

@smalltalkExample{newColor: aText
    | potentialColor |

    potentialColor := aText asString withBlanksTrimmed.
    potentialColor ifNotEmpty: [
        colors add: potentialColor asSymbol.
        colorList updateList.
        self selectedColorIndex: (colors indexOf: potentialColor )
        self changed: #clearUserEdits.
        self changed: #newColor.
    ].}

@smalltalkExample{selectedColorIndex
    ^ selectedColorIndex
}

@smalltalkExample{selectedColorIndex: anIndex
    | color colorName selected |
    
    selectedColorIndex := anIndex.

    selected := anIndex ~= 0.
    deleteButton enable: selected.
    colorName := selected ifTrue: [ colors at: anIndex ].
    
    selectedLabel contents: (colorName
        ifNil: ''
        ifNotNil: [ 'You selected @{1@}.' format: @{ colorName @} ]
    ).

    color := colorName
        ifNil: [ Color gray ]
        ifNotNil: [ [ Color perform: colorName ] on: MessageNotUnderstood do: [ Color gray ] ].
    window layoutMorph color: (color alpha: 0.6).}

@smalltalkExample{textEntryOn: aSymbol
    "Answer a TextModelMorph where aSymbol provides the name for the getter and setter."
    | entry |
        
    entry := TextModelMorph
        textProvider: self
        textGetter: aSymbol 
        textSetter: (aSymbol, ':') asSymbol ::
        acceptOnCR: true;
        askBeforeDiscardingEdits: false;
        hideScrollBarsIndefinitely;
        "Width is made proportional below.
        Setting height to zero causes it to use minimum height for one line."
        morphExtent: 0 @@ 0.
    entry layoutSpec proportionalWidth: 1.
    ^ entry.}

@menu
@end menu