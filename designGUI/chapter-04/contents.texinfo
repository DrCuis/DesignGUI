@node Handle user interaction
@chapter Handle user interaction

@*

This chapter covers the use of widgets in the base @cuis{} image.
We hope the examples presented in this chapter provide
enough knowledge to further explore the @cuis{} widgets and tools
present in the base image. We discuss core functionalities such as
associating a widget to a model, handling user interactions, and
updating a widget from a model. We conclude the chapter with the
fully functional @ref{Memory Game v1}.

@menu
* Button::
* Menu::
* Text entry::
* List::
* Memory game::
@end menu

@cindex widget @subentry button
@node Button
@section Button

Perhaps the simplest user interaction to implement
is responding to button clicks.
The @class{PluggableButtonMorph} supports this.

Several of the @class{Morph} subclasses are "pluggable". This means
they can be configured through composition rather than inheritance.
Configuration is achieved by specifying a model object and a selector
for messages to be sent to the model object when an interaction occurs.

Instances of the @class{PluggableButtonMorph} class can be
created with the @msg{model:action:label:} class method.
The @smalltalk{model:} keyword specifies a model object,
the @smalltalk{action:} keyword specifies a selector for the model object, and
the @smalltalk{label:} keyword specifies the text that appears in the button.

Let's demonstrate using a @class{PluggableButtonMorph} by
defining a class that opens a window containing a single button.
Initially the window background color is white.
Clicking the button toggles the color between red and blue.

Create the following class.

@smalltalkExample{Object subclass: #ButtonDemo
   instanceVariableNames: 'layout'
   classVariableNames: ''
   poolDictionaries: ''
   category: 'Demo'}

Define the following instance methods.

@smalltalkMethod{initialize,
| button extent window |
button := PluggableButtonMorph
   model: self
      action: #toggleColor
      label: 'Toggle'.
button setBalloonText: 'toggle background color'.
window := SystemWindow new.
window setLabel: 'Button Demo'; addMorph: button.
        
extent := button morphExtent.
"Add some space to the left and right of the button label."
button morphExtent: (extent x + 15) @@ extent y.
        
"Set window size to the smallest height that contains its submorphs."
layout := window layoutMorph.
layout padding: 10.
window
   morphExtent: 300 @@ layout minimumExtent y;
   openInWorld.}

@smalltalkMethod{toggleColor,
layout color: (
   layout color = Color red
      ifTrue: [ Color blue ]
      ifFalse: [ Color red ] )}

Open a Workspace and evaluate @smalltalk{ButtonDemo new}.
Hover over the "Toggle" button for a second
to see its tooltip (a.k.a balloon text).
Click the "Toggle" button several times and
note how the window background color changes.

@cindex widget @subentry menu
@node Menu
@section Menu
@cuis{} offers several easy to use options for menus
to inform or to ask the user to make a choice.

@cindex widget @subentry menu @subentry pop up
@subsection Pop up
The class @class{PopUpMenu} provides an easy way to render a dialog that
displays information, asks the user for confirmation,
or ask the user to select an option.
It is similar to the JavaScript DOM functions @code{alert} and @code{confirm}.
For example:

@figure{A pop up menu to inform, ch04-popupmenu-inform, 6}

@smalltalkExample{PopUpMenu inform: 'Something interesting just happened.'.}

@figure{A pop up menu to answer Yes or No, ch04-popupmenu-confirm, 4}

@smalltalkExample{likesIceCream := PopUpMenu confirm: 'Do you like ice cream?'.
likesIceCream print. "prints true or false"}

@figure{A pop up menu to select among two choices, ch04-popupmenu-confirm-truechoice-falsechoice, 4}

@smalltalkExample{likesIceCream := PopUpMenu
    confirm: 'Do you like ice cream?'
    trueChoice: 'Love it!'
    falseChoice: 'Not for me'.
likesIceCream print. "prints true or false"}

@figure{A pop up menu to select among several choices, ch04-popupmenu-withcaption-choosefrom, 3}

@smalltalkExample{color := PopUpMenu withCaption: 'Choose a color.' chooseFrom: #('red' 'green' 'blue').
color print. "prints choice index 1, 2, or 3"}

@cindex widget @subentry menu @subentry selection
@subsection Selection menu

The @class{SelectionMenu} class is a subclass of @class{PopupMenu}, it gives a bit more flexibility to the developer. Indeed, once the user selected a menu entry, instead of returning this index entry as @class{PopUp Menu} does, it returns an associated object to this entry. It is therefore more flexible.

For example,

@smalltalkExample{labels := #('Red sky at sunset' 'A Clockwork Orange'
   'Yellow submarine' 'Green peace' 'The Blue dot' 'Purple rain').
lines := #(3 6). "draw lines after these indexes"
menu := SelectionMenu labels: labels lines: lines.
selection := menu startUpMenu.
selection print. "prints the selected menu entry index"}

still returns the index of the selected menu entry, which may not be very helpful.

@figure{A selection menu without title, ch04-selectionmenu, 3}

What we want is a color object instead of an index. To do so,
we tell @class{SelectionMenu} about a collection of colors from which to
obtain the returned value depending on the user selected menu entry.

@smalltalkExample{@dots{}
colors := @{Color red . Color orange. Color yellow . Color green . Color blue . Color purple@}.
menu := SelectionMenu labels: labels lines: lines selections: colors.
selection := menu startUpMenu.
selection print. "prints the selected color"}

In the following example we demonstrate a use case of @class{SelectionMenu} in a @class{MenuDemo} class

@smalltalkExample{Object subclass: #MenuDemo
   instanceVariableNames: 'colorButton statusLabel window'
   classVariableNames: ''
   poolDictionaries: ''
   category: 'Demos'}

@figure{A button to invoke a selection menu, ch04-selectionmenu1, 4.5}

We put in place all the widgetery involved.

@smalltalkMethod{initialize,
colorButton := PluggableButtonMorph
   model: self
   action: #openMenu
   label: 'Select Color'.
statusLabel := LabelMorph contents: ''.

window := SystemWindow new.
window layoutMorph separation: 10.
window
   setLabel: 'Menu Demo';
   addMorph: colorButton;
   addMorph: statusLabel;
   openInWorld;
   morphExtent: (300 @@ window layoutMorph minimumExtent y)}

Once the button is clicked, we request at run time the menu with
the appropriate selection of colors from which to pick an answer.

@smalltalkMethod{colorMenu,
@return{} SelectionMenu 
   labels: #('Red sky at sunset' 'A Clockwork Orange' 'Yellow submarine' 'Green peace'
      'The Blue dot' 'Purple rain')
   selections: @{Color red . Color orange. Color yellow . Color green . Color blue . Color purple@}}

@figure{A selection menu open, ch04-selectionmenu2, 6}

then we adjust the window color and button label accordingly
@smalltalkMethod{openMenu,
| selectedColor |
(selectedColor := self colorMenu startUpMenu) ifNotNil: [
   colorButton label: selectedColor name.
   statusLabel contents: ('You selected @{1@}.' format: @{ selectedColor name @}).
   window layoutMorph color: (selectedColor alpha: 0.6) ]}

@figure{Result of the user selection in the menu, ch04-selectionmenu3, 4.5}

To run this, evaluate @smalltalk{MenuDemo new} in a Workspace.

@cindex widget @subentry menu @subentry string request
@subsection String request

The class @class{StringRequestMorph} prompts the user to enter a text response.
It can verify the response using a provided block that returns
a Boolean value indicating whether the response is valid.
It can also evaluate a block if the user clicks the cancel button.

For example:

@figure{A StringRequestMorph open, ch04-stringrequestmorph, 6}

@smalltalkExample{StringRequestMorph
    request: 'Comment'
    initialAnswer: 'no comment'
    verifying: [ :answer | answer isEmpty not ]
    do: [ :answer | answer print ]
    orCancel: [ 'canceled' print ].}

@cindex widget @subentry text entry
@node Text entry
@section Text entry

The @class{TextModelMorph} class can be used for single or multiple
line text entry.

The following code creates an instance of @class{TextModelMorph},
changes its value, and prints its value:

@smalltalkExample{tmm := TextModelMorph withText: 'initial content'.
tmm openInWorld.
tmm editor actualContents: 'new content'.
tmm text print.}

Typically you will want to modify many aspects of this morph
such as its size and whether words automatically wrap to a new lines.

The value associated with a @class{TextModelMorph} is either
held in a @class{TextModel} object or a @class{Text} object.

There are three common ways to create an instance of @class{TextModelMorph}.
The choice is based on how the initial value is supplied
and where the current value is held.

@enumerate

@item
@smalltalk{TextModelMorph withText: aTextOrString}

   This creates a @class{TextModel} object
   that is initialized with the given value,
   passes it to the next method, and returns what that returns.

@item
@smalltalk{TextModelMorph withModel: aTextModel}

   The approach allows the same @class{TextModel} to be used by multiple other morphs.
   It creates an instance, sets its model to @smalltalk{aTextModel},
   and returns the instance.

@item
@smalltalk{TextModelMorph textProvider: aTextProvider textGetter: selectorSymbol1 textSetter: selectorSymbol2}

   This approach allows the value to maintained in
   any object (@smalltalk{aTextProvider}) that responds to the given selectors.
   It creates an instance, sets @smalltalk{newModel} to
   an instance of @class{PluggableTextModel} that uses @smalltalk{aTextProvider},
   adds @smalltalk{aTextProvider} as a dependent of @smalltalk{newModel},
   sets its model to @smalltalk{newModel},
   and returns the instance.

@end enumerate

To display prompting text inside a @class{TextModelMorph}
until the user begins typing a value,
send it @msg{emptyTextDisplayMessage:} with a string message.

The default background color of a @class{TextModelMorph} is white.
A @class{TextModelMorph} only displays a border when it has focus.
One way to make its bounds apparent when it doesn't have focus
is to set the background color of the parent component.

@smalltalkExample{tmm owner color: (Color blue alpha: 0.1)}

Another way is to set the background color of the @class{TextModelMorph}.

@smalltalkExample{tmm color: (Color blue alpha: 0.1)}

By default, words that would extend past the right side wrap to the next line.
To prevent wrapping:

@smalltalkExample{tmm wrapFlag: false}

By default, when there are more lines than fit in the height,
a vertical scroll bar appears.
When wrapping is turned off, if the text does not fit in the width
then a horizontal scroll bar appears.

To prevent scroll bars from appearing,
send one of the following messages to an instance:

@itemize
@item
@msg{hHideScrollBar} for horizontal (doesn't seem to work!)

@item
@msg{vHideScrollBar} for vertical (doesn't seem to work!)

@item
@msg{hideScrollBarsIndefinitely} for both
@end itemize

The default size of a @class{TextModelMorph} is 200 by 100.
This is set in the @method{initialize} method of @class{PluggableMorph},
which is the superclass of @class{PluggableScrollPane},
which is the superclass of @class{TextModelMorph}.
Depending on the font, the default size displays around four lines
of wrapping text with around 17 characters per line.

To change the size:

@smalltalkExample{tmm morphExtent: width @@ height}

The size should include space for scroll bars if they may be needed.

Setting the height to zero causes it to actually be set to
the height required for a single line in the current font.

By default, pressing the tab key does not move focus from
one @class{TextModelMorph} instance to another.
To enable this, do the following for each instance:

@smalltalkExample{tmm tabToFocus: true}

When the user changes the text in a @class{TextModelMorph},
the object that holds its value is not automatically updated.
To manually request the update:

@smalltalkExample{tmm scroller acceptContents}

There are multiple ways to configure user actions to trigger an update.
The easiest are:

@smalltalkExample{tmm acceptOnAny: true. "updates after every keystroke"
tmm acceptOnCR: true. "updates after return key is pressed"}

To listen for changes to the value of a @class{TextModelMorph}:

@smalltalkExample{tmm keystrokeAction: [:event |
    | value |
    value := tmm text.
    "Do something with the value."
].}

By default, if the user attempts to close a @class{SystemWindow}
and it contains @class{TextModelMorph} instances that have unsaved changes,
they are asked to confirm this with the message
"Changes have not been saved. Is it OK to cancel those changes?".
The user must select "Yes" to close the window.
To disable this check for a particular instance of @class{TextModelMorph},
send it @msg{askBeforeDiscardingEdits:} with the argument @smalltalk{false}.

The following code creates a single-line text input
with a given width that never shows scroll bars:

@smalltalkExample{tmm := TextModelMorph withText: '' ::
    hideScrollBarsIndefinitely;
    morphExtent: 200 @@ 0; "calculates required height for one line"
    wrapFlag: false.}

If the text exceeds the width,
use the left and right arrow keys to scroll the text.

To select all the content in an instance, send it @msg{selectAll}.

To select content from one index to another where both are inclusive:

@smalltalkExample{tmm selectFrom: startIndex to: endIndex.}

To place the text cursor at the end of the current content:

@smalltalkExample{index := tmm text size + 1.
tmm selectFrom: index to: index.}

The following code demonstrates listening for key events.
It prints their ASCII codes and character representations to the Transcript.

@smalltalkExample{tmm keystrokeAction: [ :evt |
   evt keyValue print.
   evt keyCharacter print.
].}

Let's combine what we have learned above to create a small application.
The user can enter their first and last name.
Clicking the "Greet" button displays a greeting message below the button.

@figure{User Interaction Demo, ch04-userinteraction-example1, 7} 

Create the class @class{UserInteractionDemo} as follows:

@smalltalkExample{Object subclass: #UserInteractionDemo
    instanceVariableNames: 'firstName greetLabel lastName'
    classVariableNames: ''
    poolDictionaries: ''
    category: 'Demo'}

Define the following accessor methods:

@smalltalkExample{firstName
    ^ firstName

firstName: aString
    firstName := aString

lastName
    ^ lastName

lastName: aString
    lastName := aString}

Define the instance method @method{textEntryOn:} as follows:

@smalltalkExample{textEntryOn: aSymbol
    "Answer a TextModelMorph where aSymbol provides
     the name for the getter and setter."
    | entry |
        
    entry := TextModelMorph
        textProvider: self
        textGetter: aSymbol
        textSetter: (aSymbol, ':') asSymbol ::
        acceptOnAny: true;
        askBeforeDiscardingEdits: false;
        hideScrollBarsIndefinitely;
        "Width is made proportional below.
        Setting height to zero causes it to use minimum height for one line."
        morphExtent: 0 @@ 0;
        tabToFocus: true;
        wrapFlag: false.
    entry layoutSpec proportionalWidth: 1.
    ^ entry.}

Define the instance method @method{rowLabeled:} as follows:

@smalltalkExample{rowLabeled: aString for: aMorph
    "Answer a row LayoutMorph containing a LabelMorph and a given morph."
    | row |
        
    row := LayoutMorph newRow
        gap: 10;
        addMorph: (LabelMorph contents: aString);
        addMorph: aMorph.
    row layoutSpec proportionalHeight: 0.
    ^ row.}

Define the instance method @method{greet} as follows:

@smalltalkExample{greet
    | greeting |

    greeting := firstName isEmpty
        ifTrue: ''
        ifFalse: [ 'Hello @{1@} @{2@}!' format: @{firstName. lastName@} ].
    greetLabel contents: greeting.}

Define the instance method @method{initialize} as follows:

@smalltalkExample{initialize
    | button extent firstNameEntry form image lastNameEntry window |
    
    firstName := ''.
    lastName := ''.
    
    "Relative file paths start from the Cuis-Smalltalk-Dev-UserFiles directory."
    form := Form fromFileNamed: './hot-air-balloon.png' :: magnifyBy: 0.5.
    image := ImageMorph newWith: form.
    
    firstNameEntry := self textEntryOn: #firstName.
    lastNameEntry := self textEntryOn: #lastName.
    button := PluggableButtonMorph model: self action: #greet label: 'Greet'.
    
    greetLabel := LabelMorph contents: ''.
    
    window := SystemWindow new.
    window layoutMorph separation: 10.
    window
        setLabel: 'User Interaction Demo';
        addMorph: image;
        addMorph: (self rowLabeled: 'First Name:' for: firstNameEntry);
        addMorph: (self rowLabeled: 'Last Name:' for: lastNameEntry);
        addMorph: button;
        addMorph: greetLabel.
            
    "Set window size to the smallest height that contains its submorphs."
    extent := window layoutMorph minimumExtent.
    window
        morphExtent: 400 @@ extent y;
        openInWorld.
        
    "Set a background color so it's clear where the TextModelMorphs
    are placed when they do not have focus."
    window layoutMorph color: (Color blue alpha: 0.1).}

@cindex widget @subentry list
@node List
@section List

The @class{PluggableListMorph} displays a scrollable list of items.
Users can select an item by clicking it or by typing its first few letters.

Let's create a small application that allows users to select a color
from a list to change the background color of the window.
Users can also add new colors and delete existing colors.

In addition to demonstrating the use of @class{PluggableListMorph},
we will also see how to disable buttons when their use is not appropriate.

@figure{List Demo, ch04-userinteraction-example2, 5} 

Create the following class:

@smalltalkExample{Object subclass: #ListDemo
    instanceVariableNames: 'colorList colors deleteButton
        newColorEntry selectedColorIndex selectedLabel window'
    classVariableNames: ''
    poolDictionaries: ''
    category: 'Demos'}

Add the following instance methods:

@smalltalkMethod{initialize,
| addButton layout row |
    
colors := SortedCollection newFrom: #(red orange yellow green blue purple).
selectedColorIndex := 0.
colorList := PluggableListMorph
   withModel: self
   listGetter: #colors
   indexGetter: #selectedColorIndex
   indexSetter: #selectedColorIndex:.
colorList layoutSpec proportionalWidth: 1.
    
newColorEntry :=  self textEntryOn: #newColor.
newColorEntry emptyTextDisplayMessage: 'new color'.
    
addButton := PluggableButtonMorph model: self action: #addColor label: 'Add'.
    
row := LayoutMorph newRow
   gap: 10;
   addMorph: newColorEntry;
   addMorph: addButton.

deleteButton := PluggableButtonMorph
   model: self
   action: #deleteColor
   label: 'Delete Selected Color'.
    
selectedLabel := LabelMorph contents: ''.
window := SystemWindow new.    
window
   setLabel: 'List Demo';
   addMorph: colorList;
   addMorph: row;
   addMorph: deleteButton;
   addMorph: selectedLabel;
   openInWorld.

"sets initial background color"
self selectedColorIndex: 0. 

"Set window size to the smallest height that contains its submorphs."
layout := window layoutMorph.
layout separation: 10.
window morphExtent: 250 @ layout minimumExtent y}

@smalltalkMethod{addColor,
self newColor: newColorEntry text}

@smalltalkMethod{colors,
@return{} colors}

@smalltalkMethod{deleteColor,
selectedColorIndex = 0 ifFalse: [
   colors removeAt: selectedColorIndex.
   self selectedColorIndex: 0.
   colorList updateList.
   selectedLabel contents: '' ]}

@smalltalkMethod{newColor,
"In this app there is no need to retrieve this value or even hold it in an instance variable@comma{} but TextModelMorph requires that this method exists."
    
@return{} ''}

@smalltalkMethod{newColor: aText,
| potentialColor |

potentialColor := aText asString withBlanksTrimmed.
potentialColor ifNotEmpty: [
   colors add: potentialColor asSymbol.
   colorList updateList.
   self selectedColorIndex: (colors indexOf: potentialColor )
   self changed: #clearUserEdits.
   self changed: #newColor ]}

@smalltalkMethod{selectedColorIndex,
@return{} selectedColorIndex}

@smalltalkMethod{selectedColorIndex: anIndex,
| color colorName selected |
    
selectedColorIndex := anIndex.

selected := anIndex ~= 0.
deleteButton enable: selected.
colorName := selected ifTrue: [ colors at: anIndex ].
    
selectedLabel contents: (colorName
   ifNil: ''
   ifNotNil: [ 'You selected @{1@}.' format: @{ colorName @} ] ).

color := colorName
   ifNil: [ Color gray ]
   ifNotNil: [ [ Color perform: colorName ] on: MessageNotUnderstood do: [ Color gray ] ].
window layoutMorph color: (color alpha: 0.6)}

@smalltalkMethod{textEntryOn: aGetter,
"Answer a TextModelMorph where aGetter provides the symbol for the getter."
| entry |
        
entry := TextModelMorph
   textProvider: self textGetter: aGetter textSetter: (aGetter@comma{} ':') asSymbol ::
   acceptOnCR: true;
   askBeforeDiscardingEdits: false;
   hideScrollBarsIndefinitely.

Setting height to zero causes it to use minimum height for one line."
entry morphExtent: 0 @@ 0.
"Width is made proportional.
entry layoutSpec proportionalWidth: 1.
@return{} entry}

@node Memory game
@section Memory game
To illustrate user interactions with the mouse, we present in this section a memory color game. This is a board game where a collection of cards are presented to the user with a common neutral color, each card has its own color, hidden at game start-up. The user must find the cards sharing the same color. When the user clicks on a card, its color is revealed, the card with the matching color must be found. When a pair of cards are found, these cards are not playable anymore; if not, the cards' color are hidden again.

Two morphs are used in the design of the game: a kind of @class{SystemWindow} and a kind of @class{PluggableButtonMorph}. The complete source is presented in the appendix @ref{Memory Game v1} of the book. We will not present every part of the code design, but we will focus on the illustrative ones in regard of the topic of this chapter.

@figure{Memory color game,ch04-MemoryGame,8}

@cindex widget @subentry button
@subsection The card
What are the attributes we want a card to have? We need a card to have a specific @emph{card color} and a status flag to inform if we are @emph{done} with the card.

The card is a morph able to paint itself with a color. It reacts to user click to flip itself between its own @emph{card color} and the common neutral color. What we want is a kind of button:

@smalltalkExample{PluggableButtonMorph subclass: #MemoryCard
   instanceVariableNames: 'cardColor done'
   classVariableNames: ''
   poolDictionaries: ''
   category: 'MemoryGameV1'}

the default color, common to all the card is white

@smalltalkMethod{defaultColor,
@return{} Color white}

it knows to be flipped when its @smalltalk{cardColor} is used as the color of the button

@smalltalkMethod{isFlipped,
@return{} color = cardColor }

and the card can flip between this common color and its own @smalltalk{cardColor}

@smalltalkMethod{flip,
color := self isFlipped ifTrue: [self defaultColor] ifFalse: [cardColor].
self redrawNeeded}

@smalltalk{color} is used to paint the button; when adjusting it, we send the message @msg{redrawNeeded} to the button to force its redraw.

@cindex widget @subentry window
@subsection The board
What are the attributes of the game board? It knows about the @emph{playground} set with a specific @emph{size} where the @emph{cards} are presented to the user. It communicates messages through its @emph{status bar} and it knows if the user is @emph{playing} or not.

The game is presented in a window with all these attributes:

@smalltalkExample{SystemWindow subclass: #MemoryGameWindow
   instanceVariableNames: 'size cards tupleSize statusBar playground playing'
   classVariableNames: ''
   poolDictionaries: ''
   category: 'MemoryGameV1'}

The board presents a toolbar, its playground and status bar in the window column @smalltalk{layoutMoprh}

@smalltalkMethod{initialize,
super initialize.
size := 4 @@ 3.
tupleSize := 2.
playing := true.
playground := LayoutMorph newColumn.
self installToolbar.
self addMorph: playground.
self installCards.
self installStatusBar}

Indeed, by default a @class{SystemWindow} comes with a layout, set as a column. The @smalltalk{playground} is also a column layout, the cards are arranged into it in several rows.

@cuis{} does not come with any notion of toolbar, but it is fairly easy to create one with a row layout and buttons:

@smalltalkMethod{installToolbar,
| toolbar button |
toolbar := LayoutMorph newRow separation: 2.
button := PluggableButtonMorph model: self action: #startGame :: 
   enableSelector: #isStopped;
   icon: Theme current playIcon;
   borderWidth: 2;
   borderColor: Color black;
   setBalloonText: 'Play the game';
   morphExtent: 32 asPoint.
toolbar addMorph: button.
@dots{}
self addMorph: toolbar layoutSpec: LayoutSpec new useMorphHeight}

Observe the @smalltalk{enableSelector: #isStopped}, indeed the ``Play'' button is only active when the game @smalltalk{isStopped}. The same applies with the ``Stop'' button -- not shown here. The toolbar height -- row layout -- is shrunk to the height of its submorphs, to do so the toolbar is added to the window with the appropriate specification @smalltalk{LayoutSpec new useMorphHeight}.

The cards are installed in several rows in the @smalltalk{playground}, previously emptied. We remember about each card in a special @smalltalk{cards} array we can access with x and y coordinates, also the position in the playground. The colors to be used are randomly chosen and arranged in  :

@smalltalkMethod{installCards,
| colors  row |
playground removeAllMorphs.
cards := Array2D  newSize: size.
colors := self distributeColors shuffled.
1 to: size y do: [:y |
   row := LayoutMorph newRow.
   1 to: size x do: [:x | | card |
      card := MemoryCard model: self action: #flip: actionArgument: x@@y.
      card layoutSpec proportionalWidth: 1; proportionalHeight: 1.
      card cardColor: colors removeFirst.
      row addMorph: card.
      cards at: x@@y put: card ].
   playground addMorph: row ]}

We make the card interactive (it is a button), when clicked the message @msg{flip:} is sent to the game window with argument the position in the @smalltalk{cards} array and playground:

@smalltalkExample{MemoryCard model: self action: #flip: actionArgument: x@@y}

@cindex morph @subentry @msg{lock}
The core of the game logic is in the @method{flip:} method. It first flips and locks@footnote{The @msg{lock} message is part of the @class{Morph} protocol, it suppresses all kind of user interaction with a given morph.} the clicked card

@smalltalkMethod{flip: position,
| flippedCards |
(cards at: position) flip; lock.}

then it detects if all the flipped cards share the same color. To do so, we do a clever trick of Smalltalk: we collect all the colors of the flipped cards, then converts the collection of color as a @class{Set}, all duplicated colors are removed. If the resulting set size is not 1, it means cards have different colors. In that case inform the user with a message, then unflip and unlock the clicked cards:

@smalltalkExample{flippedCards := self flippedCards.
(flippedCards collect: [:aCard | aCard cardColor]) asSet size = 1 ifFalse: [
   "Give some time for the player to see the color of this card "
   self message: 'Colors do not match!'.
   self world doOneCycleNow.
   (Delay forSeconds: 1) wait.
   " Color does not match@comma{} unflip the flipped cards and unlock "
   flippedCards do: [:aCard | aCard flip; unlock].
   @return{} self]}

If the colors match, we check if we reach the @smalltalk{tupleSize} association count -- initialized by default to 2, to make pair of cards. If so, we make the cards to flash and we mark them as @smalltalk{done} so they can't be played anymore

@smalltalkExample{
   flippedCards size = tupleSize ifTrue: [
      " We found a n-tuple! "
      self message: 'Great!' bold@comma{} ' You find a '@comma{} tupleSize asString@comma{} '-tuple!'.
      flippedCards do: #flash.
      flippedCards do: #setDone.}

At this point of the game logic, in the event of a game win, we inform the user and update the game status

@smalltalkExample{
      self isGameWon ifTrue: [
         self message: 'Congatuluation@comma{} you finished the game!' bold red.
         playing := false] ]}


During the game logic, at several occurrences, we informed the user
through messages. The message are printed in the status bar set at initialize time:

@smalltalkMethod{installStatusBar,
statusBar := TextParagraphMorph new
   padding: 2;
   color: Color transparent;
   borderWidth: 1;
   borderColor: self borderColor twiceLighter ;
   setHeightOnContent.
self addMorph: statusBar layoutSpec: LayoutSpec new useMorphHeight.
self message: 'Welcome to '@comma{} 'Memory Game' bold}

Its companion method to inform with a message is then a question of updating the @class{TextParagraphMorph} contents:

@smalltalkMethod{message: aText,
statusBar contents: aText ;
   redrawNeeded }

@cindex text
@cindex widget @subentry text

A message set to the status bar can be more than a plain string, it can be a @class{Text} instance with styling attributes. To do so, we send dedicated messages to a string, for example @smalltalk{'hello' bold} converts the 'hello' string as a @class{Text} set with a bold styling attribute.

Examples of styling:

@smalltalkExample{'Hello' red bold.
'Hello ' italic, ' my love' red bold.}

To discover more messages, browse the method categories @label{text conversion ...} of the @class{CharacterSequence} class.
