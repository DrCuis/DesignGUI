@node Design GUI application
@chapter Design GUI application

@quotation
Don't ask whether you can do something, but how to do it.
@author Adele Goldberg
@end quotation

@*

In the previous chapter we explained how to handle user interactions on widgets as button and text editor. We illustrated it with a complete memory game; we did not particularly pay attention to how the responsibilities were spread across the various involved objects. In a small project it does not really mater, however as soon as you want your project to grow it may lead to complicate code, difficult to make evolve and to maintain.

@menu
* Responsibilities::
* Model View Presenter::
* The Three Musketeers ::
@end menu

@node Responsibilities
@section Responsibilities
In @acronym{OOP, Object Oriented Programming} we like each object to be responsible of its assigned business. Of course we can assign kind of extended businesses to a few objects as we did in @ref{Memory Game v1} but this is not good design.

A project growing produces legacy code, when the responsibilities of the objects are not properly bounded it makes this code difficult to understand and to maintain. A developer willing to make changes will face various challenges and difficulty: to distinguish how the responsibilities are spread across the involved objects, if any; to face long methods hard to understand; to replace one behaviour or one class by another one, in that circumstance it may require to replace several behaviors; to collaborate with several developers, each one working independently in once facet of the project,...

A good practice is to design an object with a clearly assigned task, ideally only one per object; each methods of the object should come with meaningful names@footnote{The book @emph{Smalltalk with Style} is worth reading to write good Smalltalk code.} and each one with a clearly assigned task too, ideally method should not be longer than 10 lines.

With this practice in mind, when it comes to @acronym{GUI} application development, there is this well known design pattern @acronym{MVC, Model View Controller} or its alternative @acronym{MVP,Model View Presenter}; in this design the responsibilities are spread on three orthogonal axes with no conceptual overlap.

In the following sections we present the details of this design applied step by step to the memory game presented in the previous chapter.

@cindex @acronym{MVP,Model View Controller}
@cindex @acronym{MVP,Model View Presenter}
@node Model View Presenter
@section Model View Presenter

@acronym{MVC}@footnote{@url{https://en.wikipedia.org/wiki/Model-view-controller}} and @acronym{MVP}@footnote{@url{https://en.wikipedia.org/wiki/Model-view-presenter}} designs are very close. @acronym{MVC}, nowadays widely used in GUI and Web application developments, was invented by the Smalltalk community in the late seventies and early  eighties. @acronym{MVP} is a subtle variation where the presenter has more responsibilities than the controller and acts more as a middle-man between the model and view objects.

Let's review the responsibilities of each three objects.

@itemize
   @item
   @strong{Model.} This object defines a domain by its intrinsic characteristics, related to the intended goal. A Person model may have attributes like family name, first name and gender; or in another design it could have an unique anonymous identifier attribute.

The model knows nothing about the view and presenter involved in the design. However, a model modifying itself its attributes should have a way to notify the views to update their representation of the model, it is the role of the dependency mechanism explained later in the chapter.

   @item
   @strong{View.} It is responsible to display to the user a meaningful view of the model, here before a Person model. The view can be passive to display the attribute of a Person model or interactive to edit the attributes of the Person model. One model may be displayed by one or several different views, @emph{therefore a model object has no knowledge of the views} acting on it.
   @item
   @strong{Presenter.} This object acts as a middle-mam between the
model and the view, instantiating and gluing both and acting as the entry point in the application@footnote{This is an assumed variation from the view used as the entry point of the traditional approach. Being a middle-man, it makes sense it is instantiated first.}.

The presenter also handles the user actions mediated by the views of a given model. Therefore, when the user edit a text entry, click on a button, select an entry in a menu or drag a visual object, the event is handled to the presenter. Then it decides, depending on the context and the state of the application, what to do with the event, like updating the state of the application and handling suited data to the model eventually.

@end itemize

Now, let's see how to reshape our memory game to fit it in the @acronym{MVP} design.

@subsection Memory Game Model

The model is the isolated object, without knowledge of the presenter and the view@footnote{Though several models may know about each other.}, it is easier to start from there.

In the previous design of the game, we had two classes @class{MemoryGameWindow} and @class{MemoryCard} acting as view and model. Therefore we need to extract what is model related.

Our game involves the domain of a game with cards, we define two models:

@itemize
   @item
   @class{MemoryCardModel}. It knows about the intrinsic characteristics of a card in the context of the memory game. In the earlier game design, the view knows about its @smalltalk{cardColor} and its states @smalltalk{done}, @smalltalk{flipped}; the latter one was deduced by a method based on the color attribute of the view. These three attributes are clearly part of the card model and need to be represented by three attributes:

@smallexample
Object subclass: #MemoryCardModel
   instanceVariableNames: 'flipped done color'
   classVariableNames: ''
   poolDictionaries: ''
   category: 'MemoryGameV2'
@end smallexample

We add the necessary initialization and methods to externally get the state and to update it:

@smallexample
MemoryCardModel >> initialize
   done := flipped := false

MemoryCardModel>>setDone
   done := true

MemoryCardModel>>isDone
   @return{} done

MemoryCardModel>>isFlipped
   @return{} flipped
@end smallexample

   @item
   @class{MemoryGameModel}. This model defines what is a memory game. In the previous game design we had 6 attributes, a mix of view and domain related attributes: @smalltalk{size}, @smalltalk{cards}, @smalltalk{tupleSize}, @smalltalk{statusBar}, @smalltalk{playground} and @smalltalk{playing}. Only the first three attributes are related to the characteristic of the game, we may hesitate on the later one @smalltalk{playing}, but it will prove to be more useful in the presenter to determine the state of the application.

@smallexample
Object subclass: #MemoryGameModel
   instanceVariableNames: 'size tupleSize cards'
   classVariableNames: ''
   poolDictionaries: ''
   category: 'MemoryGameV2'
@end smallexample



@end itemize


 and @class{MemoryCardModel}


@subsection Memory Game View

@subsection Memory Game Presenter


@node The Three Musketeers
@section The Three Musketeers

The model, the view and the presenter are tied together. Unlike the three musketeers which were tied together by friendship and the fight for justice, our three objects are tied together by the dependency mechanism we were a little acclimated with in the previous chapter.

How the M-V-P are tied together?

Why observer patter over change/update?
In fact both: at widget change/update; at app level observer pattern
