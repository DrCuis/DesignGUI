@node Design GUI application
@chapter Design GUI application

@quotation
Don't ask whether you can do something, but how to do it.
@author Adele Goldberg
@end quotation

@*

In the previous chapter we explained how to handle user interactions on widgets as button and text editor. We illustrated it with a complete memory game; we did not particularly pay attention to how the responsibilities were spread across the various involved objects. In a small project it does not really mater, however as soon as you want your project to grow it may lead to complicate code, difficult to make evolve and to maintain.

@menu
* Responsibilities::
* Model View Presenter::
* The Three Musketeers ::
@end menu

@node Responsibilities
@section Responsibilities
In @acronym{OOP, Object Oriented Programming} we like each object to be responsible of its assigned business. Of course we can assign kind of extended businesses to a few objects as we did in @ref{Memory Game v1} but this is not good design.

A project growing produces legacy code, when the responsibilities of the objects are not properly bounded it makes this code difficult to understand and to maintain. A developer willing to make changes will face various challenges and difficulty: to distinguish how the responsibilities are spread across the involved objects, if any; to face long methods hard to understand; to replace one behaviour or one class by another one, in that circumstance it may require to replace several behaviors; to collaborate with several developers, each one working independently in once facet of the project,...

A good practice is to design an object with a clearly assigned task, ideally only one per object; each methods of the object should come with meaningful names@footnote{The book @emph{Smalltalk with Style} is worth reading to write good Smalltalk code.} and each one with a clearly assigned task too, ideally method should not be longer than 10 lines.

With this practice in mind, when it comes to @acronym{GUI} application development, there is this well known design pattern @acronym{MVC, Model View Controller} or its alternative @acronym{MVP,Model View Presenter}; in this design the responsibilities are spread on three orthogonal axes with no conceptual overlap.

In the following sections we present the details of this design applied step by step to the memory game presented in the previous chapter.

@cindex @acronym{MVC,Model View Controller}
@cindex @acronym{MVP,Model View Presenter}
@node Model View Presenter
@section Model View Presenter

@acronym{MVC}@footnote{@url{https://en.wikipedia.org/wiki/Model-view-controller}} and @acronym{MVP}@footnote{@url{https://en.wikipedia.org/wiki/Model-view-presenter}} designs are very close. @acronym{MVC}, nowadays widely used in GUI and Web application developments, was invented by the Smalltalk community in the late seventies and early  eighties. @acronym{MVP} is a subtle variation where the presenter has more responsibilities than the controller and acts more as a middle-man between the model and view objects.

Let's review the responsibilities of each three objects.

@itemize
   @item
   @strong{Model.} This object defines a domain by its intrinsic characteristics, related to the intended goal. A Person model may have attributes like family name, first name and gender; or in another design it could have an unique anonymous identifier attribute.

The model knows nothing about the view and presenter involved in the design. However, a model modifying itself its attributes should have a way to notify the views to update their representation of the model, it is the role of the dependency mechanism explained later in the chapter.

   @item
   @strong{View.} It is responsible to display to the user a meaningful view of the model, here before a Person model. The view can be passive to display the attribute of a Person model or interactive to edit the attributes of the Person model. One model may be displayed by one or several different views, @emph{therefore a model object has no knowledge of the views} acting on it.
   @item
   @strong{Presenter.} This object acts as a middle-mam between the
model and the view, instantiating and gluing both and acting as the entry point in the application@footnote{This is an assumed variation from the view used as the entry point of the traditional approach. Being a middle-man, it makes sense it is instantiated first.}.

The presenter also handles the user actions mediated by the views of a given model. Therefore, when the user edit a text entry, click on a button, select an entry in a menu or drag a visual object, the event is handled to the presenter. Then it decides, depending on the context and the state of the application, what to do with the event, like updating the state of the application and handling suited data to the model eventually.

@end itemize

Now, let's see how to reshape our memory game to fit it in the @acronym{MVP} design.


@cindex @acronym{MVP,Model View Presenter} @subentry model
@subsection Memory Game Model

The model is the isolated object, without knowledge of the presenter and the view@footnote{Though several models may know about each other.}, it is easier to start from there.

In the previous design of the game, we had two classes @class{MemoryGameWindow} and @class{MemoryCard} acting as view and model. Therefore we need to extract what is model related.

Our game involves the domain of a game with cards, we define two models:

@itemize
   @item
   @class{MemoryCardModel}. It knows about the intrinsic characteristics of a card in the context of the memory game. In the earlier game design, the @class{MemoryCard} view knows about its @smalltalk{cardColor} and its states @smalltalk{done}, @smalltalk{flipped}; the latter one was deduced by a method based on the color attribute of the view. These three characteristics are clearly part of the card model and need to be represented by instance attributes:

@smallexample
Object subclass: #MemoryCardModel
   instanceVariableNames: 'flipped done color'
   @dots{}
@end smallexample

We add the necessary initialization and methods to externally get the state and to update it:

@smallexample
MemoryCardModel>>initialize
   done := flipped := false

MemoryCardModel>>setDone
   done := true

MemoryCardModel>>isDone
   @return{} done

MemoryCardModel>>isFlipped
   @return{} flipped
@end smallexample

   @item
   @class{MemoryGameModel}. This model defines what is a memory game. The previous @class{MemoryGameWindow} had 6 instances variables, a mix of view and domain related attributes: @smalltalk{size}, @smalltalk{cards}, @smalltalk{tupleSize}, @smalltalk{statusBar}, @smalltalk{playground} and @smalltalk{playing}. Only the first three attributes are related to the characteristic of the game, we may hesitate on the later one @smalltalk{playing}, but it will prove to be more useful in the presenter to determine the state of the application.

@smallexample
Object subclass: #MemoryGameModel
   instanceVariableNames: 'size tupleSize cards'
   @dots{}
@end smallexample

  @itemize
    @item
    @smalltalk{size}. A point representing the disposition of the cards. @smalltalk{4@@3} are 3 rows of 4 cards.

    @item
    @smalltalk{tupleSize}. An integer, the number of associated cards to find, by default 2.

    @item
    @smalltalk{cards}. The collection of @class{MemoryCardModel} instances.
  @end itemize

We have the necessary methods to initialize the instance and to create the card models. Compared to its counterpart @method{MemoryGameWindow>>installCards} of the previous design, the method @method{installCards} here after is much simpler and easier to understand because it only instantiate the card models. Separation of responsibility is paying off:

@smallexample
MemoryGameModel>>initialize	
   size := 4 @@ 3.
   tupleSize := 2

MemoryGameModel>>installCardModels
   | colours |
   cards := Array2D newSize: size.
   colours := self distributeColors.
   1 to: size y do: [:y |
      1 to: size x do: [:x | 
         cards
            at: x@@y
            put: (MemoryCardModel new color: colours removeFirst) ] ]
@end smallexample

In this class, we also import, unchanged, the behaviors of @class{MemoryGameWindow} fitting the game model: @method{distributeColors}, @method{doneCards}, @method{flippedCards}, @method{undoneCards} and @method{isGameWon}.

That's it for the models of the game.
@end itemize

@cindex @acronym{MVP,Model View Presenter} @subentry view
@subsection Memory Game View
We have defined two model classes, so we may expect to define two view classes. Well, not necessary, here we just need to define one view class for the whole game and we use an existing view of @cuis{} for the card model, the @class{PluggableButtonMorph}

We need to reshape @class{MemoryGameWindow} to contain only view related business, first in its attributes then its behaviors. First at all, @strong{a view always knows about its presenter}, it can even know about the model through the mediation of the presenter:
@smallexample
MemoryGameView>>presenter: aPresenter
   presenter := aPresenter.
   self model: presenter model
@end smallexample

It also knows about some other views needed for its internal organisation and regulation:
@smallexample
SystemWindow subclass: #MemoryGameWindow
   instanceVariableNames: 'presenter statusBar playground'
   @dots{}
@end smallexample

Again the behaviors is stripped down to only view considerations and the @method{initialize} method is shortened. Installing the toolbar slightly differs, the model of the buttons is not any more the view but the presenter:

@smallexample
MemoryGameWindow>>installToolbar
   | toolbar button |
   toolbar := LayoutMorph newRow separation: 2.
   button := PluggableButtonMorph model: presenter action: #startGame :: 
      enableSelector: #isStopped;
   @dots{}
@end smallexample

Indeed, we explained earlier it is the presenter responsibility to handle user events, the actions remain the same and we can anticipate the related methods will be transferred from the view to the presenter class.

Now, we should look at installing the card view, it relies on the already instantiated card models. The logic of installing the card models then the card views is handled by the presenter, the middle-man:

@smallexample
MemoryGameView>>installCards
   | row size |
   playground removeAllMorphs.
   size := model size.
   1 to: size y do: [:y |
      row := LayoutMorph newRow.
      1 to: size x do: [:x | | cardModel cardView |
         cardModel := model cards at: x@@y.
         cardView := PluggableButtonMorph
            model: presenter
            action: #flip:
            actionArgument: x@@y.
         @dots{}
	 cardView layoutSpec proportionalWidth: 1; proportionalHeight: 1.
	 cardView color: cardModel backColor.
	 row addMorph: cardView].
      playground addMorph: row ]
@end smallexample

For clarity, we have presented above a shortened version of the @method{installCards} method without the dependency between the card model and card view. We discuss it later in this chapter.

@cindex @acronym{MVP,Model View Presenter} @subentry presenter
@subsection Memory Game Presenter


@node The Three Musketeers
@section The Three Musketeers

The model, the view and the presenter are tied together. Unlike the three musketeers which were tied together by friendship and the fight for justice, our three objects are tied together by the dependency mechanism we were a little acclimated with in the previous chapter.

How the M-V-P are tied together?

Why observer patter over change/update?
In fact both: at widget change/update; at app level observer pattern
