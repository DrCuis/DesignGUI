@node Advanced design patterns in GUI
@chapter Advanced design patterns in GUI

@*

In section @ref{Design a GUI application} we presented a fundamental
design pattern of GUI application. As the development of your GUI
application progresses and grows in complexity, you may want to use
additional design patterns. The book @emph{Design Patterns Smalltalk
Companion} is a must to read for any serious application
development. Design patterns help to develop code easier to maintain;
there are a common ground easing mutual understanding.

In the following sections we present several of these patterns with
concrete use cases in application developed with the @cuis{} system.

@menu
* Command::Manage undo and redo operations
* Flyweight::Factory to create or retrieve objects
* Builder::Build object according to user given input
* Template Method::Generalize a building process then specialize 
* State::Manage GUI tools and tool states
* Bridge::Output a GUI representation to a file
* Strategy::Adapt to various host platform
@end menu

@cindex undo @seeentry{design pattern}
@cindex redo @seeentry{design pattern}
@cindex design pattern @subentry undo
@cindex design pattern @subentry redo
@cindex design pattern @subentry command
@node Command
@section Command

Among the design patterns it is likely one that impact the most the
end-user: it lets you implement the undo and redo operations.

The template repository
@label{CuisApp}@footnote{@url{https://github.com/hilaire/CuisApp}}
demonstrates the design of a picture viewer, as a simple Cuis
application example. The user can rotate, flip and scale a picture

Its undo and redo actions are implemented with three classes:

@itemize

@item
@class{AppCommandStack}. Its instance records the history of
commands. It is a sort of @class{ReadWriteStream} with additional
behavior, particularly to truncate the stack of commands. Indeed, when
a new command is inserted in the stack -- it may not be at the end
depending on the user activation of the @label{undo} action -- the
tail of the stack must be truncated with the @method{truncate}
method. A @method{previous} method is also needed for the @label{undo}
action.

@item
@class{AppCommandManager}. Its instance manages the stack of commands:
create new commands from user actions then undo and redo commands. For
each specific user action, there is a dedicated method:
@method{flipHorizontally}, @method{rotateLeft}, @method{zoomIn}, etc.

All these methods share the same pattern: instantiate a command, then
execute it:

@smalltalkMethod{flipHorizontally,
|command|
command := stack nextPut: (AppFlipHCommand presenter: presenter).
@return{} command execute}

Some command requires additional parameters:

@smalltalkMethod{rotateLeft,
|command|
command := stack nextPut: (AppRotateCommand presenter: presenter).
command degrees: -90.
@return{} command execute}

@item
@class{AppCommand}. The top-level class of a hierarchy of commands,
one for each user operations. There are the sub classes
@class{AppFlipHCommand}, @class{AppRotateCommand}, etc. Each of these
classes implement the @method{execute} and @method{unexecute} methods
differently.

For some action as flip horizontally, the @method{unexecute} is
identical to @method{execute}:

@smalltalkMethod{AppFlipHCommand>>execute,
self imageMorph image: (self imageMorph form flippedBy: #vertical)}

@smalltalkMethod{AppFlipHCommand>>unexecute,
self execute}

Rotating requires an additional behavior (@method{rotatedBy:} not
copied here) :

@smalltalkMethod{AppRotateCommand>>execute,
self imageMorph image: (self rotatedBy: degrees)}

@smalltalkMethod{AppRotateCommand>>unexecute,
self imageMorph image: (self rotatedBy: degrees negated)}

The @method{execute} and @method{unexecute} methods void there
effects. In some circumstance, the @method{execute} may have a
destructive effect as it happens in the zoom out action, an additional
attribute is then used to keep a copy of the initial data:

@smalltalkMethod{AppZoomOutCommand>>execute,
cacheForm := self imageMorph form.
self imageMorph image: (cacheForm magnifyBy: 0.5)}

So undoing restore properly the data:

@smalltalkMethod{AppZoomOutCommand>>unexecute,
self imageMorph image: cacheForm}

How @method{execute} and @method{unexecute} are implemented really
depends on the nature of the command.

@end itemize

@ignore 
---
  config:
    class:
      hideEmptyMembersBox: true
---
classDiagram
class Command{
   presenter
   execute()
   unexecute()
}

class RotateCommand{
   degrees
   degrees:()
   rotateBy:()
}
class ZoomOutCommand {
   cacheForm
}

class CommandStack~ReadWriteStream~
class CommandManager {
   stack
   presenter
   undo()
   redo()
   rotateLeft()
   rotateRight()
   flipHorizontally()
   flipVertically()
   zoomIn()
   zoomOut()
}

Command <|-- FlipHCommand
Command <|-- FlipVCommand
Command <|-- RotateCommand
Command <|-- ZoomInCommand
Command <|-- ZoomOutCommand

CommandStack --> "0..n" Command
CommandManager --> "1" CommandStack

@end ignore

@figure{Command pattern diagram (for ease of reading the @emph{App}
prefix is removed),commandDiagram,16}

@subsection Memory game with undo/redo

What will be the implication to implement the undo and redo actions
within our game? Our game is simple, the user can only click one card
at a time, therefore we want to record this and also the consequences
on the game state, if any. The consequences can be none, matching
cards or non matching cards; each resulting in a different changed
game state.

When implementing the user interaction with a command, the
@method{execute} method will deal with these three possible
outcomes. Its @method{unexecute} counterpart will have to reverse the
game to its original state.

If the game state has a small memory footprint, it is less cumbersome
to just save its state before executing each user action. The game
state is the collection of each card's status: the done and flipped
Boolean values.

Our Memory game just need to be flanked with the command classes we
described earlier, unchanged. Then the @class{Command} hierarchy will
have one subclass @class{PlayCardCommand}:

@smalltalkExample{Command subclass: #PlayCardCommand
   tanceVariableNames: 'status position'
   @dots{}}

It captures the game state in its @smalltalk{status} attribute, of
the same nature as the cards array in the Memory game model:

@smalltalkMethod{initialize,
status := Array2D newSize: presenter model cards size}

At command execution,  

@smalltalkMethod{execute,
self backupModels.
presenter flip: position}

the game state is backed up before flipping the card:

@smalltalkMethod{backupModels,
| size |
size := presenter model cards size.
1 to: size y do: [:y |
   1 to: size x do: [:x | | card |
      card := presenter model cards at: x@@y.
      status at: x@@y put: (Array with: card isFlipped with: card isDone) ]]}

The undo action restores the game state before execution:

@smalltalkMethod{unexecute,
" Restore the status of the card models "
| size |
size := status size.
1 to: size y do: [:y |
   1 to: size x do: [:x | | cardStatus card |
      card := presenter model cards at: x@@y.
      cardStatus := status at: x@@y.
      card 
         flip: cardStatus first;
         done: cardStatus second ] ]}

The card models's @method{flip:} and @method{done:} methods are refactored to
trigger events propagated to the card view:

@smalltalkMethod{MemoryCardModel>>flip: boolean,
" Set my flip state and trigger a color event for my view accordingly to my flip state "
| newColor |
flipped = boolean ifTrue: [@return{} self].
flipped := boolean.
newColor := flipped ifTrue: [color] ifFalse: [self backColor].
self triggerEvent: #color with: newColor}

and

@smalltalkMethod{done: boolean,
done = boolean ifTrue: [@return{} self].
done := boolean.
self triggerEvent: (done ifTrue: [#lock] ifFalse: [#unlock])}

In @ref{Memory Game v3}, you will find the complete source of the
modified Memory game: toolbar with undo and redo buttons.


@cindex design pattern @subentry flyweight
@node Flyweight
@section Flyweight

The idea of the flyweight pattern is to have objects in one place and
to avoid duplication. It is often associated with the factory pattern,
so this will be both the place where objects are manufactured or
retrieved.

DrGeo use the flyweight and factory patterns to manage the geometric
objects created by the user. A geometric object is manufactured once
the user provided enough information by selecting a set of existing
objects in a sketch.

To create a segment AB, the user selects point A and point B. If the
user creates a new segment and selects again the point A and the point
B, a new segment is not created but instead the existing segment AB is
answered. Identically, if the user selects point B then point A, the
same existing segment AB is answered. 

This mechanism occurs in the flyweight factory. In DrGeo there are
three classes. An abstract @class{DrGFactory}:

@smalltalkExample{Object subclass: #DrGFactory
   instanceVariableNames: 'pool last'
   classVariableNames: ''
   poolDictionaries: ''
   category: 'DrGeo-Factories'}

then two sub-classes @class{DrGMacroFactory} and @class{DrGMathItem}
to manage the pool of macro-constructions and mathematics items.

The existing objects are hold in a pool of objects,

@smalltalkMethod{initialize,
pool := OrderedCollection new}

when a new object is pushed in the factory, it is first searched in
the pool,

@smalltalkMethod{pushAsLastWhenInPool: anItem,
"if this item has a twin in the pool@comma{} push as last this last one and return true@comma{}
otherwise return false"

@return{} (self findInPool: anItem)
   ifNotNil: [ :item | 
      self last: item.
      true ]
   ifNil: [ false ]}


To find in the pool, its index, if any, is searched

@smalltalkMethod{findInPool: item,
"Try to find a twin of this mathItem@comma{} if so return the twin@comma{} otherwise nil"
@return{} self at: (self indexOf: item in: pool)}


Determining if an object has a twin depends on the nature of each
object.  It is done through hash and equality check at the object
level

@smalltalkMethod{indexOf: anItem in: aPool,
"No identity equality but hashed value to detect duplicated object we must consider as equal"
@return anItem 
   ifNil: [0]
   ifNotNil: [aPool findFirst: [ :each | 
      each hash = anItem hash
      "double check when hash is equal (can be a collision)"
      and: [each = anItem] ] ]}


@cindex design pattern @subentry template method

If we look at our segment AB example, we want to establish segment AB
and segment BA are the same mathematics object.

In DrGeo, the geometric object model uses the template method pattern to
establish how equality is articulated:

@smalltalkMethod{DrGMathItem>>= aMathItem,
@return{} aMathItem isMathItem 
   ifFalse: [false]
   ifTrue: [self basicType == aMathItem basicType
      and: [self nodeType == aMathItem nodeType
      and: [self parentsEqual: aMathItem]]]}

For a segment defined by two points, @smalltalk{basicType} is
@smalltalk{#segment} and @smalltalk{nodeType} is
@smalltalk{#'2pts'}.

The subclasses of @class{DrGMathItem} implement the
@method{parentsEqual:}. In @class{DrGSegment2ptsItem} we cross check
if the extremities of the segments are the same points:

@smalltalkMethod{parentsEqual: aMathItem,
((parents first = aMathItem parents first) and:
[parents second = aMathItem parents second])
   ifTrue: [@return{} true].
   
((parents first = aMathItem parents second) and:
[parents second = aMathItem parents first])
   ifTrue: [@return{} true].
   
@return{} false}

Comparing can be slow, therefore we compare first the hash value of
each objects, pre-computed:


@smalltalkMethod{rehash,
@return{} hash := ((parents sorted: [:ptA :ptB | ptA point <= ptB point]) hash 
   bitXor: self nodeType hash) 
   bitXor: self basicType hash}

These details show the tricky part in this pattern: how to establish
two objects are identical. With objects representing mathematics items
it is difficult, the identity check done by DrGeo is very
limited. After all, we could have two segments mathematically
identical through a process of transformations and only a mathematics
solver could establish it.

@cindex design pattern @subentry builder
@node Builder
@section Builder
A builder is an object specialized to construct one or several types
of object, the type of the constructed object depends on the nature of
the inputs sent to the builder. Explained differently, depending on
input received by the builder, it will figure out what and how to
construct a new object with the provided inputs.

@cindex design pattern @subentry template method

In DrGeo there is a whole hierarchy of 39 builders. The abstract class
@class{DrGMathItemBuilder} provides the general mechanism through
template methods. When an object is added to the builder, first it is
asked if it is wanted or not. Next, once the object is added to the
builder, it is asked if the builder is ready to build a new object, if
so an event propagated to whatever is listening

@smalltalkMethod{add: aMathItemCollection at: aPoint,
"
Add a math item in the selection list of the builder@comma{} aPoint is the position where the action took place. Return true if mathItem accepted
"
(self isWanted: aMathItemCollection at: aPoint) ifTrue: [
   self addItem: aMathItemCollection at: aPoint.
   "Are we done? If so notify our dependent"
   self readyToBuild ifTrue: [self triggerEvent: #readyToBuild].
   @return{} true].
@return{} false}

Let's look at the subclass @class{DrGBuilderMiddle}, a builder to
construct the middle of two points or a segment.

@smalltalkExample{DrGMathItemBuilder subclass: #DrGMiddleBuilder
   instanceVariableNames: 'pointA pointB segment'
   classVariableNames: ''
   poolDictionaries: ''
   category: 'DrGeo-Presenter-Builder'}

The template methods are implemented to fit the task. The middle
builder wants item which are either point or segment but also
depending on the history of the already added item to the builder.

@smalltalkMethod{isWanted: aMathItemCollection,
@return{} aMathItemCollection notEmpty 
   and: [
      (aMathItemCollection first isPointItem and: [aMathItemCollection first ~= pointA])
      or: [aMathItemCollection first isSegmentItem and: [pointA isNil]]
      ]}

Observe a segment is not wanted if a point -- pointA -- was already
provided to the builder.

Adding an item to a builder also depends on the history of added item,
pointB will be set once pointA is already known:

@smalltalkMethod{addItem: aMathItemCollection at: aPoint,
super addItem: aMathItemCollection at: aPoint.
aMathItemCollection first isPointItem 
   ifTrue: [
      pointA ifNil: [
         pointA := aMathItemCollection first.
         @return{} self].
      pointB ifNil: [
         pointB := aMathItemCollection first.
         @return{} self ] ]
   ifFalse: [segment := aMathItemCollection first]}

Once the segment or the point A and B are known, we are ready to build
middle point:

@smalltalkMethod{readyToBuild,
@return{} segment notNil or: [pointA notNil and: [pointB notNil]]}

@node Template Method
@section Template Method
to build geometric items

@node State
@section State
To manage tools

@node Bridge
@section Bridge
DrGSvgCanvas

@node Strategy
@section Strategy
To manage hierarchy of platform

