@node Advanced design patterns in GUI
@chapter Advanced design patterns in GUI

@*

In section @ref{Design a GUI application} we presented a fundamental
design pattern of GUI application. As the development of your GUI
application progresses and grows in complexity, you may want to use
additional design patterns. The book @emph{Design Patterns Smalltalk
Companion} is a must to read for any serious application
development. Design patterns help to develop code easier to maintain;
there are a common ground easing mutual understanding.

In the following sections we present several of these patterns with concrete use
cases in application.

@menu
* Command::Manage undo and redo operations
* Flyweight::Factory to create or retrieve objects
* Builder::Build object according to user given input
* Template Method::Generalize a building process then specialize 
* State::Manage GUI tools and tool states
* Bridge::Output a GUI representation to a file
* Strategy::Adapt to various host platform
@end menu

@cindex undo
@cindex redo
@cindex design pattern @subentry command
@node Command
@section Command

Among the design patterns it is likely one that impact the most the
end-user: it lets you implement the undo and redo operations.

The template repository
@label{CuisApp}@footnote{@url{https://github.com/hilaire/CuisApp}}
demonstrates the design of a picture viewer, as a simple Cuis
application example. The user can rotate, flip and scale a picture

Its undo and redo actions are implemented with three classes:

@itemize

@item
@class{AppCommandStack}. Its instance records the history of
commands. It is a sort of @class{ReadWriteStream} with additional
behavior, particularly to truncate the stack of commands. Indeed, when
a new command is inserted in the stack -- it may not be at the end
depending on the user activation of the @label{undo} action -- the
tail of the stack must be truncated with the @method{truncate}
method. A @method{previous} method is also needed for the @label{undo}
action.

@item
@class{AppCommandManager}. Its instance manages the stack of commands:
create new commands from user actions then undo and redo commands. For
each specific user action, there is a dedicated method:
@method{flipHorizontally}, @method{rotateLeft}, @method{zoomIn}, etc.

All these methods share the same pattern: instantiate a command, then
execute it:

@smalltalkMethod{flipHorizontally,
|command|
command := stack nextPut: (AppFlipHCommand presenter: presenter).
@return{} command execute}

Some command requires additional parameters:

@smalltalkMethod{rotateLeft,
|command|
command := stack nextPut: (AppRotateCommand presenter: presenter).
command degrees: -90.
@return{} command execute}

@item
@class{AppCommand}. The top-level class of a hierarchy of commands,
one for each user operations. There are the sub classes
@class{AppFlipHCommand}, @class{AppRotateCommand}, etc. Each of these
classes implement the @method{execute} and @method{unexecute} methods
differently.

For some action as flip horizontally, the @method{unexecute} is
identical to @method{execute}:

@smalltalkMethod{AppFlipHCommand>>execute,
self imageMorph image: (self imageMorph form flippedBy: #vertical)}

@smalltalkMethod{AppFlipHCommand>>unexecute,
self execute}

Rotating requires an additional behavior (@method{rotatedBy:} not
copied here) :

@smalltalkMethod{AppRotateCommand>>execute,
self imageMorph image: (self rotatedBy: degrees)}

@smalltalkMethod{AppRotateCommand>>unexecute,
self imageMorph image: (self rotatedBy: degrees negated)}

The @method{execute} and @method{unexecute} methods void there
effects. In some circumstance, the @method{execute} may have a
destructive effect as it happens in the zoom out action, an additional
attribute is then used to keep a copy of the initial data:

@smalltalkMethod{AppZoomOutCommand>>execute,
cacheForm := self imageMorph form.
self imageMorph image: (cacheForm magnifyBy: 0.5)}

So undoing restore properly the data:

@smalltalkMethod{AppZoomOutCommand>>unexecute,
self imageMorph image: cacheForm}

How @method{execute} and @method{unexecute} are implemented really
depends on the nature of the command.

@end itemize

@ignore 
---
  config:
    class:
      hideEmptyMembersBox: true
---
classDiagram
class Command{
   presenter
   execute()
   unexecute()
}

class RotateCommand{
   degrees
   degrees:()
   rotateBy:()
}
class ZoomOutCommand {
   cacheForm
}

class CommandStack~ReadWriteStream~
class CommandManager {
   stack
   presenter
   undo()
   redo()
   rotateLeft()
   rotateRight()
   flipHorizontally()
   flipVertically()
   zoomIn()
   zoomOut()
}

Command <|-- FlipHCommand
Command <|-- FlipVCommand
Command <|-- RotateCommand
Command <|-- ZoomInCommand
Command <|-- ZoomOutCommand

CommandStack --> "0..n" Command
CommandManager --> "1" CommandStack

@end ignore

@figure{Command pattern diagram (for ease of reading the @emph{App}
prefix is removed),commandDiagram,16}

@subsection Memory game with undo/redo

What will be the implication to implement the undo and redo actions
within our game? Our game is simple, the user can only click one card
at a time, therefore we want to record this and also the consequences
on the game state, if any. The consequences can be none, matching
cards or non matching cards; each resulting in a different changed
game state.

When implementing the user interaction with a command, the
@method{execute} method will deal with these three possible
outcomes. Its @method{unexecute} counterpart will have to reverse the
game to its original state.

If the game state has a small memory footprint, it is less cumbersome
to just save its state before executing each user action. The game
state is the collection of each card's status: the done and flipped
Boolean values.

Our Memory game just need to be flanked with the command classes we
described earlier, unchanged. Then the @class{Command} hierarchy will
have one subclass @class{PlayCardCommand}:

@smalltalkExample{Command subclass: #PlayCardCommand
   tanceVariableNames: 'status position'
   @dots{}}

It captures the game state in its @smalltalk{status} attribute, of
the same nature as the cards array in the Memory game model:

@smalltalkMethod{initialize,
status := Array2D newSize: presenter model cards size}

At command execution,  

@smalltalkMethod{execute,
self backupModels.
presenter flip: position}

the game state is backed up before flipping the card:

@smalltalkMethod{backupModels,
| size |
size := presenter model cards size.
1 to: size y do: [:y |
   1 to: size x do: [:x | | card |
      card := presenter model cards at: x@@y.
      status at: x@@y put: (Array with: card isFlipped with: card isDone) ]]}

The undo action restores the game state before execution:

@smalltalkMethod{unexecute,
" Restore the status of the card models "
| size |
size := status size.
1 to: size y do: [:y |
   1 to: size x do: [:x | | cardStatus card |
      card := presenter model cards at: x@@y.
      cardStatus := status at: x@@y.
      card 
         flip: cardStatus first;
         done: cardStatus second ] ]}

The card models's @method{flip:} and @method{done:} methods are refactored to
trigger events propagated to the card view:

@smalltalkMethod{MemoryCardModel>>flip: boolean,
" Set my flip state and trigger a color event for my view accordingly to my flip state "
| newColor |
flipped = boolean ifTrue: [@return{} self].
flipped := boolean.
newColor := flipped ifTrue: [color] ifFalse: [self backColor].
self triggerEvent: #color with: newColor}

and

@smalltalkMethod{done: boolean,
done = boolean ifTrue: [@return{} self].
done := boolean.
self triggerEvent: (done ifTrue: [#lock] ifFalse: [#unlock])}

In @ref{Memory Game v3}, you will find the complete source of the
modifier Memory game.

@node Flyweight
@section Flyweight
factory

@node Builder
@section Builder
to build geometric items

@node Template Method
@section Template Method
to build geometric items

@node State
@section State
To manage tools

@node Bridge
@section Bridge
DrGSvgCanvas

@node Strategy
@section Strategy
To manage hierarchy of platform

